# ソースコードの解説

## calkinwilfTree

単に再帰するだけです。

## calkinwilfSeq

queueもwalkも再帰していてパッと見だと訳分からない！となるかもしれないので、補足説明をしておきます。

```haskell
t1 = Bin t2 x1 t3
t2 = Bin t4 x2 t5
t3 = Bin t6 x3 t7
...
```

というデータ構造になっているとします。

```haskell
q1 = t1 : walk q1
walk (Bin l _ r : q) = l : r : walk q
```

と書かれているとして、q1を順に展開していきましょう。

```haskell
q1 = t1 : walk q1
   = t1 : t2 : t3 : walk q2
          |______q2_______|
   = t1 : t2 : t3 : t4 : t5 : walk q3
               |_________q3_________|
   = t1 : t2 : t3 : t4 : t5 : t6 : t7 : walk q4
                    |___________q4____________|
   = ...
```

以下同様に続いていきます。まさにキューのようになっているのが分かると思います。

## calkinwilfSeqAnother

calkinwilfSeqの別解です。

levelsでは木を深さごとに分けたリストのリストを作っています。levelsはきれいに再帰的に書けることがわかります。

あとは、このリストをすべてつなぎあわせれば幅優先走査の完了です！

ちなみに、リストの結合で少し余分に時間を食うので、差分リストを使えばもう少し早くなります。

## calkinwilfGet

せっかく二分木の構造が与えられているので、digitsでnを二進数の桁に分解して、その情報をつかって、funcで木を根から下っていきます。

## calkinwilfParent

ある節点の左の子は必ず1より小さく、右の子は必ず1より大きいということを利用します。

## calkinwilfPrev

自分がある節点の左の子である限り親をたどっていきます。この回数をkとします。そして右の子になったら、親に行ってその左の子に行きます。そしてまたk回右の子をたどります。そしてたどりついた値が答えになります。kを割り算によって定数時間で求められるのがポイントです。

ただし、k回親をたどると1/1にたどりつく可能性もあります。このときは親を0/1とし、その左の子を0/1とします。その右の子は1/1となります。これで上手くいくのです。

Calkin-Wilf木の根を0/1にしてみます。すると、この木の左端はずっと0/1になります。この木を横に見ていくと、Calkin-Wilf列が最初から横にのびていっていて、下に行けばいくほど長くなっているのがわかります。さらに上にも0/1を無限に伸ばしていってみましょう。この両方向に無限である二分木を横に見ていくと、なんと、どこを取ってもCalkin-Wilf列が無限に伸びていきます。

こうして考えてみると、このコードの意味がよりよくつかめてくるはずです。

## calkinwilfNext

calkinwilfPrevと同様、右の子である限り親をたどって(k回とします)、左の子になったら親に行ってその左の子に行って、k回左の子をたどれば、答えが得られます。kは割り算によって定数時間で求めます。
